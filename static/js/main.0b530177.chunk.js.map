{"version":3,"sources":["methods.js","components/game-racing.jsx","components/game-snake.jsx","App.js","serviceWorker.js","index.js"],"names":["getRandom","min","max","Math","ceil","floor","random","Racing","cellSize","canvasWidth","props","canvasHeight","cellNumberHorizont","state","gameGoing","carLocation","barriers","acceleration","crash","carOnTheLeft","carOnTheRight","maxBarriersAmount","carHeight","carWidth","speed","playerScore","moveBarriers","i","length","y","setState","x","addBarrier","push","upSpeed","steeringWheelDown","event","keyCode","steeringWheelUp","listener","console","log","letsGo","intervalMove","setInterval","intervalAdd","intervalSpeed","ctx","document","getElementById","getContext","this","clearRect","fillStyle","fillRect","clearInterval","canvas","width","height","img","Image","src","onload","drawImage","font","textPositionHorizintally","measureText","fillText","window","addEventListener","drawFrame","removeEventListener","btnClassName","canvasClassName","Fragment","className","onClick","id","ref","React","Component","Snake","cellNumberVertical","body","apple","moveDirection","moveDirectionChanged","uroboros","changeMoveDirection","moveSnake","prevBody","newBody","toRight_headX","toRight_headY","toTop_headX","toTop_headY","toLeft_headX","toLeft_headY","toBottom_headX","toBottom_headY","setApple","item","slice","newBodyPart","head","find","evaluation","txt","App","to","path","exact","render","Boolean","location","hostname","match","ReactDOM","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0b530177.chunk.js","sourcesContent":["export const getRandom = (min, max) => {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1)) + min; //Максимум и минимум включаются\r\n};","import React from 'react';\r\n\r\nimport { getRandom } from '../methods'\r\n\r\nexport default class Racing extends React.Component {\r\n\r\n    cellSize = 10; // размер ячейки\r\n    canvasWidth = this.props.canvasWidth;\r\n    canvasHeight= this.props.canvasHeight;\r\n    cellNumberHorizont = this.canvasWidth/this.cellSize;    // кол-во клеток по горизонтали\r\n    \r\n    state = {\r\n        gameGoing: false,\r\n        carLocation: 0,\r\n        barriers: [],\r\n        acceleration: false,\r\n        crash: false,\r\n        carOnTheLeft: true,\r\n        carOnTheRight: false,\r\n        maxBarriersAmount: 20,\r\n        carHeight: 4,\r\n        carWidth: 2,\r\n        speed: 5,\r\n        playerScore: 0\r\n    }\r\n\r\n    moveBarriers = () => {\r\n        const { barriers, acceleration, carLocation, carWidth, carHeight, speed, playerScore } = this.state;\r\n        const { cellSize, canvasHeight, cellNumberHorizont } = this;\r\n\r\n        // определяем положение каджого барьера\r\n        for (let i = 0; i < barriers.length; i++) {\r\n\r\n            // если барьер доехал до нижнего края, перемещаем его наверх с новой случайной координатой Х\r\n            if ( barriers[i].y > canvasHeight) {\r\n                this.setState({\r\n                    playerScore: playerScore+1\r\n                });\r\n                barriers[i].y = 0;\r\n                barriers[i].x = getRandom(0, cellNumberHorizont - 1);\r\n                \r\n            }\r\n\r\n            // определяем скорость движения (с ускорением или без) с помощью acceleration из state\r\n            if ( !acceleration ) {\r\n                barriers[i].y = barriers[i].y + speed;\r\n            }\r\n            else  {\r\n                barriers[i].y = barriers[i].y + speed + 20;\r\n            }\r\n            \r\n            // проверяем наезд машины на барьер\r\n            if (\r\n                    barriers[i].y >= canvasHeight - carHeight * cellSize\r\n                    && barriers[i].x >= carLocation \r\n                    && barriers[i].x < carLocation + carWidth\r\n                ) {\r\n                this.setState({\r\n                    crash: true,\r\n                    gameGoing: false\r\n                })\r\n            }\r\n        }\r\n        \r\n        // ставим барьры в новые положения\r\n        this.setState({\r\n            barriers: barriers\r\n        })\r\n    }\r\n\r\n    addBarrier = () => {\r\n        const { cellNumberHorizont } = this;\r\n        const { barriers, maxBarriersAmount } = this.state;\r\n\r\n        if( barriers.length < maxBarriersAmount ) {\r\n            barriers.push(\r\n                {\r\n                    x: getRandom(0, cellNumberHorizont - 1),\r\n                    y: 0\r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n    upSpeed = () => {\r\n        const { speed } = this.state;\r\n\r\n        if( speed < 50 ) {\r\n            this.setState({\r\n                speed: speed + 1\r\n            })\r\n        }\r\n    }\r\n\r\n    steeringWheelDown = (event) => {     // рулевое колесо\r\n        switch (event.keyCode) {\r\n            case 37:\r\n                if ( !this.state.carOnTheLeft ) {\r\n                    this.setState({\r\n                        carLocation: this.state.carLocation - 1\r\n                    })\r\n                }\r\n            break;\r\n\r\n            case 39:\r\n                if ( !this.state.carOnTheRight ) {\r\n                    this.setState({\r\n                        carLocation: this.state.carLocation + 1\r\n                    })\r\n                }\r\n            break;\r\n\r\n            case 38:\r\n                this.setState({\r\n                    acceleration: true\r\n                })\r\n            break;\r\n            \r\n            default: \r\n            break;\r\n        }\r\n    }\r\n\r\n    steeringWheelUp = (event) => {     // рулевое колесо\r\n        switch (event.keyCode) {\r\n            case 38:\r\n                this.setState({\r\n                    acceleration: false\r\n                })\r\n            break;\r\n\r\n            default: \r\n            break;\r\n        }\r\n    }\r\n\r\n    listener = (event) => {\r\n        console.log(1)\r\n      };\r\n\r\n    drawFrame( carLocation, barriers ) {\r\n        const ctx = document.getElementById('canvas').getContext('2d');\r\n\r\n        const { carWidth, carHeight } = this.state;\r\n        const { cellSize, canvasWidth, canvasHeight } = this;\r\n\r\n        // очищаем канвас перед отрисовкой нового фрейма\r\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n        // рисуем машину\r\n        ctx.fillStyle = 'brown';\r\n        ctx.fillRect( carLocation*cellSize, canvasHeight - carHeight * cellSize, carWidth * cellSize, canvasHeight );\r\n\r\n        // рисуем препятствия\r\n        ctx.fillStyle = '#212121';\r\n        for (let i = 0; i < this.state.barriers.length; i++) {\r\n            ctx.fillRect(barriers[i].x*cellSize,barriers[i].y,cellSize,cellSize);\r\n        }\r\n\r\n        // проверка не у левого края ли стоит машина\r\n        if (carLocation*cellSize <= 0 && this.state.carOnTheLeft === false) {\r\n            this.setState({\r\n                carOnTheLeft: true\r\n            })\r\n        }\r\n        else if ( carLocation*cellSize > 0 && this.state.carOnTheLeft === true ) {\r\n            this.setState({\r\n                carOnTheLeft: false\r\n            })\r\n        }\r\n\r\n        // проверка не у правого края ли стоит машина\r\n        if (carLocation*cellSize >= canvasWidth-carWidth*cellSize && this.state.carOnTheRight === false) {\r\n            this.setState({\r\n                carOnTheRight: true\r\n            })\r\n        }\r\n        else if ( carLocation*cellSize < canvasWidth-carWidth*cellSize && this.state.carOnTheRight === true ) {\r\n            this.setState({\r\n                carOnTheRight: false\r\n            })\r\n        }\r\n    }\r\n\r\n    letsGo = () => {\r\n        const { cellNumberHorizont } = this;\r\n        this.setState({\r\n            gameGoing: true,\r\n            carLocation: 0,\r\n            barriers: [{\r\n                x: getRandom(0, cellNumberHorizont - 1),\r\n                y: 0\r\n            }],\r\n            acceleration: false,\r\n            crash: false,\r\n            carOnTheLeft: true,\r\n            carOnTheRight: false,\r\n            maxBarriersAmount: 20,\r\n            carHeight: 4,\r\n            carWidth: 2,\r\n            speed: 5,\r\n            playerScore: 0,\r\n        })\r\n        this.intervalMove = setInterval(() => this.moveBarriers(), 50);   // запускаем двигатель барьеров\r\n        this.intervalAdd = setInterval(() => this.addBarrier(), 5000);    // запускаем добавлятель барьеров\r\n        this.intervalSpeed = setInterval(() => this.upSpeed(), 8000);     // увеличиваем скорость\r\n    }\r\n\r\n    crash() {\r\n        // при аварии очищаем интервалы\r\n        clearInterval(this.intervalMove);\r\n        clearInterval(this.intervalAdd);\r\n        clearInterval(this.intervalSpeed);\r\n\r\n        // и рисуем на весь экран картинку аварии\r\n        const canvas = document.getElementById('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        var img = new Image();\r\n        img.src = 'https://image.freepik.com/vector-gratis/bubble-pop-art-of-crash-icon-comunicacion-comica-retro-tema-expresion_18591-10094.jpg';\r\n\r\n        img.onload = function(){\r\n            ctx.drawImage(img,0,0,canvas.width,canvas.height);\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        const canvas = document.getElementById('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        ctx.font = \"18px arial\";\r\n        const startText = 'Для начала нажмите \"GO!\"'\r\n        const textPositionHorizintally = canvas.width/2 - ctx.measureText(startText).width/2\r\n        ctx.fillText(startText, textPositionHorizintally, canvas.height/2);\r\n        window.addEventListener('keydown', this.steeringWheelDown);\r\n        window.addEventListener('keyup', this.steeringWheelUp);\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        const { carLocation, barriers } = this.state;\r\n\r\n        if (!this.state.crash) {\r\n            this.drawFrame( carLocation, barriers );\r\n        }\r\n        else {\r\n            this.crash();\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        clearInterval(this.intervalMove);\r\n        clearInterval(this.intervalAdd);\r\n        clearInterval(this.intervalSpeed);\r\n        window.removeEventListener('keydown', this.steeringWheelDown);\r\n        window.removeEventListener('keyup', this.steeringWheelUp);\r\n    }\r\n\r\n    render() {\r\n        let btnClassName;\r\n        let canvasClassName;\r\n\r\n        if ( this.state.gameGoing ) {\r\n            btnClassName = 'start-button hidden';\r\n            canvasClassName = 'game no-cursor';\r\n        }\r\n        else {\r\n            btnClassName = 'start-button';\r\n            canvasClassName = 'game';\r\n        }\r\n\r\n        return (\r\n            <React.Fragment>\r\n                <div className='game-header'>\r\n                    <span>Игра: Гонки</span>\r\n                    <span className=\"player-score\">Ваш счет: {this.state.playerScore}</span>\r\n                </div>\r\n                <button className={ btnClassName } onClick={this.letsGo}>GO!</button>\r\n                <canvas id='canvas' className={canvasClassName} ref=\"canvas\" width={this.props.canvasWidth} height={this.props.canvasHeight} />\r\n            </React.Fragment>\r\n        );\r\n    }\r\n}","import React from 'react';\r\n\r\nimport { getRandom } from '../methods'\r\n\r\nexport default class Snake extends React.Component {\r\n\r\n    cellSize = 10; // размер ячейки\r\n    canvasWidth = this.props.canvasWidth;\r\n    canvasHeight = this.props.canvasHeight;\r\n    cellNumberHorizont = this.canvasWidth/this.cellSize;    // кол-во клеток по горизонтали\r\n    cellNumberVertical = this.canvasHeight/this.cellSize;   // кол-во клеток по вертикали\r\n\r\n    state = {\r\n        gameGoing: false,\r\n        body: [\r\n            { x: 1, y: 0 },\r\n            { x: 0, y: 0 },\r\n        ],\r\n        apple: {},\r\n        moveDirection: 'toRight',\r\n        moveDirectionChanged: false,\r\n        speed: 1,\r\n        playerScore: 0,\r\n        crash: false,\r\n        uroboros: false,\r\n    }\r\n\r\n    drawFrame() {\r\n\r\n        const ctx = document.getElementById('canvas').getContext('2d');\r\n\r\n        const { body, apple, playerScore } = this.state;\r\n        const { cellSize, canvasWidth, canvasHeight } = this;\r\n\r\n        // очищаем канвас\r\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n        // рисуем змею\r\n        for (let item of body) {\r\n            if (item === body[0]) {\r\n                ctx.fillStyle = 'black';\r\n            }\r\n            else {\r\n                ctx.fillStyle = 'brown';\r\n            }\r\n            ctx.fillRect(item.x * cellSize, item.y * cellSize, cellSize, cellSize);\r\n        }\r\n\r\n        /* \r\n            если голова попадает на яблоко - пушим в body дополнительную клетку\r\n            и ставим яблоко на новое место\r\n            и увеличиваем счет игрока\r\n        */\r\n        if (body[0].x === apple.x && body[0].y === apple.y) {\r\n            let newBody = body.slice();\r\n            let newBodyPart = newBody[newBody.length - 1]\r\n            newBody.push(newBodyPart)\r\n\r\n            this.setState({\r\n                playerScore: playerScore + 1,\r\n                body: newBody\r\n            })\r\n            this.setApple();\r\n        }\r\n\r\n        // рисуем яблоко\r\n        ctx.fillStyle = 'green';\r\n        ctx.fillRect(apple.x * cellSize, apple.y * cellSize, cellSize, cellSize);\r\n\r\n\r\n        // проверки на аварии\r\n\r\n        // врезался сам в себя\r\n        let head = body[0];\r\n        let bodyWithoutHead = body.slice(1);\r\n        let crash_uroboros = bodyWithoutHead.find(item => item.x === head.x && item.y === head.y);\r\n        if (crash_uroboros) {\r\n            this.setState({\r\n                crash: true,\r\n                uroboros: true,\r\n                gameGoing: false\r\n            })\r\n        }\r\n\r\n        // голова вышла за пределы канваса\r\n        if (head.x >= canvasWidth / 10 ||\r\n            head.x < 0 ||\r\n            head.y < 0 ||\r\n            head.y >= canvasHeight / 10) {\r\n            this.setState({\r\n                crash: true,\r\n                gameGoing: false\r\n            })\r\n        }\r\n    }\r\n\r\n    changeMoveDirection = (event) => {\r\n        if (!event) {\r\n            return\r\n        }\r\n        if (!this.state.moveDirectionChanged) { // сменить направление можно только 1 раз за кадр\r\n            switch (event.keyCode) {\r\n                case 37:\r\n                    if (this.state.moveDirection !== 'toRight') {\r\n                        this.setState({ moveDirection: 'toLeft' })\r\n                    }\r\n                    break;\r\n\r\n                case 38:\r\n                    if (this.state.moveDirection !== 'toBottom') {\r\n                        this.setState({ moveDirection: 'toTop' })\r\n                    }\r\n                    break;\r\n\r\n                case 39:\r\n                    if (this.state.moveDirection !== 'toLeft') {\r\n                        this.setState({ moveDirection: 'toRight' })\r\n                    }\r\n                    break;\r\n\r\n                case 40:\r\n                    if (this.state.moveDirection !== 'toTop') {\r\n                        this.setState({ moveDirection: 'toBottom' })\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    break;\r\n            }\r\n            this.setState({\r\n                moveDirectionChanged: true  // ставим стейт что направление было изменено (ставим обратно при отрисовке нового кадра)\r\n            })\r\n        }\r\n    }\r\n\r\n    moveSnake = () => {\r\n        const { body, moveDirection } = this.state;\r\n\r\n        const prevBody = body;\r\n        let newBody = [];\r\n\r\n        switch (moveDirection) {\r\n            case 'toRight':\r\n                const toRight_headX = prevBody[0].x + 1;  // в каждом кейсе нельзя создавать переменные с одним именем (?)\r\n                const toRight_headY = prevBody[0].y;\r\n                newBody[0] = {\r\n                    x: toRight_headX,\r\n                    y: toRight_headY\r\n                }\r\n                for (let i = 1; i < body.length; i++) {\r\n                    newBody[i] = prevBody[i - 1]\r\n                }\r\n                this.setState({\r\n                    body: newBody\r\n                })\r\n                break;\r\n            case 'toTop':\r\n                const toTop_headX = prevBody[0].x;\r\n                const toTop_headY = prevBody[0].y - 1;\r\n                newBody[0] = {\r\n                    x: toTop_headX,\r\n                    y: toTop_headY\r\n                }\r\n                for (let i = 1; i < body.length; i++) {\r\n                    newBody[i] = prevBody[i - 1]\r\n                }\r\n                this.setState({\r\n                    body: newBody\r\n                })\r\n                break;\r\n            case 'toLeft':\r\n                const toLeft_headX = prevBody[0].x - 1;\r\n                const toLeft_headY = prevBody[0].y;\r\n                newBody[0] = {\r\n                    x: toLeft_headX,\r\n                    y: toLeft_headY\r\n                }\r\n                for (let i = 1; i < body.length; i++) {\r\n                    newBody[i] = prevBody[i - 1]\r\n                }\r\n                this.setState({\r\n                    body: newBody\r\n                })\r\n                break;\r\n            case 'toBottom':\r\n                const toBottom_headX = prevBody[0].x;\r\n                const toBottom_headY = prevBody[0].y + 1;\r\n                newBody[0] = {\r\n                    x: toBottom_headX,\r\n                    y: toBottom_headY\r\n                }\r\n                for (let i = 1; i < body.length; i++) {\r\n                    newBody[i] = prevBody[i - 1]\r\n                }\r\n                this.setState({\r\n                    body: newBody\r\n                })\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        this.setState({\r\n            moveDirectionChanged: false // теперь можно снова сменить направление движения\r\n        })\r\n    }\r\n\r\n    setApple() {\r\n        const { cellNumberHorizont } = this;\r\n        this.setState({\r\n            apple: {\r\n                x: getRandom(0, cellNumberHorizont - 1),\r\n                y: getRandom(0, cellNumberHorizont - 1),\r\n            }\r\n        })\r\n    }\r\n\r\n    letsGo = () => {\r\n        this.setState({\r\n            gameGoing: true,\r\n            body: [\r\n                { x: 1, y: 0 },\r\n                { x: 0, y: 0 },\r\n            ],\r\n            moveDirection: 'toRight',\r\n            playerScore: 0,\r\n            crash: false,\r\n            uroboros: false\r\n        })\r\n        this.setApple();\r\n        this.intervalAdd = setInterval(() => this.moveSnake(), 100);\r\n        this.changeMoveDirection();\r\n    }\r\n\r\n    crash() {\r\n        const { uroboros, playerScore } = this.state;\r\n        clearInterval(this.intervalAdd);\r\n\r\n        const canvas = document.getElementById('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        ctx.font = \"24px arial\";\r\n\r\n        if (uroboros) {\r\n            const img = new Image();\r\n            img.src = 'https://cdn1.radikalno.ru/uploads/2020/1/7/1b7f7d18cc6f6e4d6c13401e8c2c6cfe-full.png';\r\n\r\n            img.onload = function () {\r\n                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n            };\r\n        }\r\n\r\n        let evaluation;\r\n        if (playerScore >= 0 && playerScore < 10) {\r\n            evaluation = 'мало...'\r\n        }\r\n        else if (playerScore >= 10 && playerScore < 20) {\r\n            evaluation = 'Нормально'\r\n        }\r\n        else if (playerScore >= 20 && playerScore < 30) {\r\n            evaluation = 'Неплохо!'\r\n        }\r\n        else if (playerScore >= 30) {\r\n            evaluation = 'Круто!'\r\n        }\r\n\r\n        const txt = `Ваш счет: ${playerScore}`\r\n        ctx.fillText(txt, canvas.width / 2 - ctx.measureText(txt).width / 2, canvas.height / 2)\r\n        ctx.fillText(evaluation, canvas.width / 2 - ctx.measureText(evaluation).width / 2, canvas.height / 2 + 20)\r\n    }\r\n\r\n    componentDidMount() {\r\n        const canvas = document.getElementById('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        ctx.font = \"18px arial\";\r\n        const startText = 'Для начала нажмите \"GO!\"'\r\n        const textPositionHorizintally = canvas.width / 2 - ctx.measureText(startText).width / 2\r\n        ctx.fillText(startText, textPositionHorizintally, canvas.height / 2);\r\n        \r\n        window.addEventListener('keydown', this.changeMoveDirection);\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        if (!this.state.crash) {\r\n            this.drawFrame();\r\n        }\r\n        else {\r\n            this.crash();\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        clearInterval(this.intervalAdd);\r\n        window.removeEventListener('keydown', this.changeMoveDirection);\r\n    }\r\n\r\n    render() {\r\n        let btnClassName;\r\n        let canvasClassName;\r\n\r\n        if (this.state.gameGoing) {\r\n            btnClassName = 'start-button hidden';\r\n            canvasClassName = 'game no-cursor';\r\n        }\r\n        else {\r\n            btnClassName = 'start-button';\r\n            canvasClassName = 'game';\r\n        }\r\n\r\n\r\n        return (\r\n            <React.Fragment>\r\n                <div className='game-header'>\r\n                    <span>Игра: Змейка</span>\r\n                    <span className=\"player-score\">Ваш счет: {this.state.playerScore}</span>\r\n                </div>\r\n                <canvas id='canvas' className={canvasClassName} ref=\"canvas\" width={this.props.canvasWidth} height={this.props.canvasHeight} />\r\n                <button className={btnClassName} onClick={this.letsGo}>GO!</button>\r\n            </React.Fragment>\r\n        );\r\n    }\r\n}\r\n","import React from 'react';\nimport './App.css';\n\nimport Racing from './components/game-racing'\nimport Snake from './components/game-snake'\n\nimport { BrowserRouter as Router, Route, Link } from 'react-router-dom';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"games-container\">\n        <Router>\n          <div className='router-links'>\n            <Link to=\"/snake\">Змейка</Link>\n            <Link to=\"/racing\">Гонки</Link>\n          </div>\n          <div className=\"game-area\">\n            <Route path='/' exact render={() => <h2>Выберите игру</h2>}/>\n            <Route\n              path='/racing'\n              render={() => <Racing canvasWidth={280} canvasHeight={280} />}\n            />\n            <Route\n              path='/snake'\n              render={() => <Snake canvasWidth={280} canvasHeight={280} />}\n            />\n          </div>\n        </Router>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}